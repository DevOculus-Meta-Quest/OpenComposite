# Interface splitting and stub generation

First, go read [OpenVRInterfaces.md] to get an idea of what purpose this serves, and roughly what the output looks like.

## Interface splitting

The input to this whole process is a bunch of different `openvr.h` headers, one per version. These are stored in
`SplitOpenVRHeaders/OpenVR/openvr-<version number>.h`. These contain all the interfaces for one OpenVR version, along
with a bunch of type and structure definitions.

A given `openvr.h` file is actually made of several headers joined together, and the names of those headers can be found
in standardised comments throughout the single header, and it looks like a tool inside Valve was used to glue the
various headers together. Unfortunately we don't have access to the original headers, so we perform header splitting,
which is reverse of this process: it takes the single big header and breaks it into a bunch of different files.

Some of those files, such as `vrtypes.h`, contain type information that is often added to but almost or completely never
changes what's already there. These files are simple: they're placed directly in `SplitOpenVRHeaders/OpenVR/interfaces`.

Some of those headers, however, define interfaces. Since interfaces frequently change, they're split into different
files for each version of the interface (not by OpenVR version). For example, `IVRSystem` version `022` will always end
up in `IVRSystem_022.h`, despite the fact it was originally declared in the `ivrsystem.h` file inside Valve.
If `IVRSystem` version `022` appears in multiple OpenVR versions, the latest one will be used.

Next comes namespacing: If we simply placed each copy of `IVRSystem` in its own header, since they all define a class
of the same name in the `vr` namespace they'd collide when multiple are imported at the same time. To avoid this, the
contents of each interface header are wrapped in a namespace based on the name and version of the interface.

For example, if this is the contents of an `openvr.h` header:

```c++
// vrtypes.h

// stuff here

// ivrsystem.h

namespace vr {
class IVRSystem {
public:
    // Methods here
}
static const char * const IVRSystem_Version = "IVRSystem_022";
}
```

That would get split (ignoring  `vrtypes.h`) into `IVRSystem_022.h` which would be modified to read:

```c++
namespace vr {
namespace IVRSystem_022 { // <-- This got added
class IVRSystem {
public:
    // Methods here
}
static const char * const IVRSystem_Version = "IVRSystem_022";
}
}
```

This then allows us to access the interface as `vr::IVRSystem_022::IVRSystem` (recall something like this appears in the
declaration of `CVRCompositor_012` in [OpenVRInterfaces.md]) and the previous version as `vr::IVRSystem_021::IVRSystem`
and so on. Note any structs defined in the file will have to use the same kind of namespaced access.

This is all done by `SplitOpenVRHeaders/OpenVR/generate.py`. Note the stub generation script also used to be
called `generate.py` but located in `OpenOVR/Reimpl`, but nowadays it's been renamed to `stubs.py`.

## Stub generation

The basic form of the interface stubs were shown in [OpenVRInterfaces.md], with the two relevant files
being `GVRCompositor.gen.h` and `stubs.gen.cpp` (both in `OpenOVR/Reimpl`). These are auto-generated
by `scripts/stubs.py`.

This script has a list of interface names (if you add a completely new interface, not just a new version of an existing
one, you must edit the script to add it). For each of those interfaces, it reads `OpenOVR/Reimpl/CVR<name>.cpp` and
parses out a few magic macros: `GEN_INTERFACE` and `BASE_FLAG`, along with looking for function definitions.

Use `GEN_INTERFACE` to tell `stubs.py` to generate a CVRInterface_xyz definitions, like so:

```c++
GEN_INTERFACE("System", "011")
GEN_INTERFACE("System", "012")
```

This then causes `stubs.py` to read the `IVRSystem_011.h` and `IVRSystem_012.h` headers (as generated by the header
splitter) and generate a declaration and definition for each of those two classes.
